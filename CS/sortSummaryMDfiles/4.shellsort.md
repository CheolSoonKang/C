##### (본 페이지는 C언어 x86기준으로 작성하였습니다.)

# 셸 정렬(ShellSort)

1959년 도널드 셸에 의해 창안된 알고리즘으로, 그의 이름을 따서 붙여진 알고리즘으로

삽입 정렬의 성질을 이용하여 보완하였다.

- 삽입 정렬은 입력되는 초기리스트가 "거의 정렬"되어 있을 경우 효율적이다.
- 삽입 정렬은 한 번에 한 요소의 위치만 결정되기 때문에 비효율적이다.

셸 정렬은 주어진  입력 리스트를 특정 매개변수 값(gap)의 길이를 갖는 부분리스트로 나누고 각 부분리스트에서 삽입정렬을 수행한다.

매개변수 값(gap)을 줄이며 이 과정을 반복하고 결국 매개변수 값(gap)이 1이될 때까지 반복한다.

셸 정렬은 다음과 같은 과정으로 나눈다.

1. 데이터를  임의의 부분리스트로 나누어서 삽입 정렬한다.
2. 데이터를 다시 잘게 나누어서 삽입 정렬한다.
3. 2번 과정을 반복하면 마침내 정렬이 된다.



# main함수

```c
int main()
{
	int array[10] = {4,32,3,5,2,14,53,1,23,20};

	
	printf("before sort : ");
	for (int i = 0; i < 10;i++) {//
		printf("%3d",array[i]);
	}
	printf("\n\n");

	shellSort(array,10);

	printf("after sort : ");
	for (int i = 0; i < 10; i++) {
		printf("%3d", array[i]);
	}
	printf("\n\n");


	return 0;
}
```

int형 배열 10자리에 10개의 숫자를 무작위로 선언하였다.

main함수에서는

> 1.정렬 전 배열을 출력
>
> 2.정렬
>
> 3.정렬 된 배열 출력  순서로 진행한다.

(정렬 알고리즘을 포스팅하면서 main함수는 바뀌지 않고 정렬 방법만 바뀔 예정입니다.)



# shellSort함수

```c
//first : subList first index
//last  : sublist last index
void insertionSort(int *array,int first,int last,int gap){
    int i,j,key;

    for(int i = first + gap;i <= last;i += gap){
        key = array[i];

        for(j = i-gap; j >= first && array[j] > key; j -= gap){
            array[j+gap] = array[j];
        }
        array[j + gap] = key;
    }
}


void shellSort(int * array,int lengthOfArray){
    int i,gap;

    for(gap = lengthOfArray/2; gap > 0;gap /= 2){
        if(gap % 2 == 0){
            gap++;
        }

        for(i = 0;i < gap;i++){
            insertionSort(array,i,lengthOfArray-1,gap);
        }
    }
}
```

shellSort()함수는 int형 포인터와 배열의 크기를 파라미터로 전달 받는다.

(나중에 포스팅 할 다른 정렬들도 대부분 배열의 포인터와 크기를 파라미터로 전달할 것이다.)

부분리스트의 삽입정렬을 진행할 insertionSort()함수는 int형 포인터와 부분리스트의 '처음 인덱스(first)''와 ''마지막 인덱스(last)'' 그리고 매개변수 값(gap)을 파라미터로 전달 받는다.



1. i는 0부터 시작하여  배열의 마지막에서 두번 째 원소까지 진행한다.

2. 처음 최솟값은 i번째 원소로 임시로 정하고, j는 배열의 i+1번째 원소부터 끝까지 진행하면서

   최소값을 찾으면 해당 인덱스로 min을 교체한다.

3. min과 i값이 다르다면  i인덱스와 min인덱스의 값을 교환해준다.

4. i가 마지막에서 두번 째 원소에 도착할 때까지 ,2,3번의 과정을 반복한다.


![Selection-Sort-Animation](../images/selectionsort/Selection-Sort-Animation.gif)



 # 특징

### 장점

- 최대 자료 교환 횟수가 정해져 있음

### 단점

- 같은 값의 자료가 있을 때  순서가 바뀔 수 있음




# 시간복잡도

![timecomplex(bubblesort)](../images/selectionsort/timecomplex(selectionsort).PNG)



# References

- 위키백과 - 선택정렬
- Do it! 자료구조와 함께 배우는 알고리즘 입문(한빛미디어)
- https://gmlwjd9405.github.io/2018/05/06/algorithm-selection-sort.html